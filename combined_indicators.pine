//@version=6
// =============================================================================
//  Combined S/R + Fib (Volatility Zone v7) - Visual Refinement [Corrected]
//  ▸ AVALIAÇÃO: Refinamento visual com foco em clareza e contexto.
//  ▸ Implementa marcadores de origem para zonas S/R e âncoras Fibonacci.
//  ▸ Melhora o ciclo de vida visual das zonas (Ativa → Validada → Rompida).
//  ▸ Adiciona tooltips contextuais para zonas validadas e de confluência.
//  ▸ By: RefinadorVisualZonasPine
// =============================================================================
import jonathanmoletta17/LogisticRegressionUtils/3 as lr
import jonathanmoletta17/LogisticTrainingUtils/1 as lt
import jonathanmoletta17/PivotUtils/2 as pv
import jonathanmoletta17/ConfluenceLib/5 as conf
import jonathanmoletta17/StyleLib/4 as sty

indicator("Combined S/R + Fib (Volatility Zone v7) [Corrected]", "CSFZ_v7", overlay=true, max_lines_count=500, max_labels_count=300, max_boxes_count=100)

// Declarar cores globalmente (serão atualizadas via StyleLib)
var color borderColorRes = na
var color borderColorSup = na
var color borderColorValid = na
var color borderColorBroken = na

// ⁕ Subsistemas
srEnabled = input.bool(true, "Enable Support/Resistance", group="Subsystems")
fibEnabled = input.bool(true, "Enable Fibonacci Extensions", group="Subsystems")
confEnabled = input.bool(true, "Enable Confluence Zones", group="Subsystems")

// ⁕ Parâmetros S/R
length = input.int(14, "Pivot Length", group="Support/Resistance")
probThreshold = input.float(0.7, "Prob Threshold", minval=0, maxval=1, group="Support/Resistance")
retestCount = input.int(1, "Retests to Validate", minval=1, maxval=5, group="Support/Resistance")
volatilityBandATR = input.float(0.15, "Volatility Band Width (ATR)", step=0.05, group="Support/Resistance", tooltip="Largura da zona em múltiplos de ATR. Ex: 0.15 = Nível ± (0.15 * ATR)")
rsiThreshold = input.float(50, "RSI Threshold", group="Support/Resistance")
logW0 = input.float(1.0, "Logistic Weight 0", group="Support/Resistance")
logW1 = input.float(1.0, "Logistic Weight 1", group="Support/Resistance")
logW2 = input.float(1.0, "Logistic Weight 2", group="Support/Resistance")
useTrainedWeights = input.bool(false, "Use Trained Weights", group="Support/Resistance")
weightsStr = input.string("", "External Weights w0,w1,w2", group="Support/Resistance", tooltip="Opcional: insira pesos separados por vírgula. Deixe em branco para treinar com o histórico.")
trainRate = input.float(0.05, "Train Learning Rate", minval=0.001, step=0.001, group="Support/Resistance")
trainEpochs = input.int(50, "Train Epochs", minval=1, group="Support/Resistance")

// ⁕ Parâmetros de Confluência
confThresholdATR = input.float(0.25, "Confluence ATR Threshold", group="Confluence Engine")
confluenceBoxWidth = input.int(10, "Confluence Box Width (bars)", minval=1, group="Confluence Engine")
w1 = input.float(0.4, "Weight - Distance", group="Confluence Engine")
w2 = input.float(0.3, "Weight - Signal", group="Confluence Engine")
w3 = input.float(0.2, "Weight - Retests", group="Confluence Engine")
w4 = input.float(0.1, "Weight - Temporal", group="Confluence Engine")

// ⁕ Estilos – S/R (valores padrão via StyleLib)
srColorRes    = input.color(sty.SR_COLOR_RES,    "Resistance (Active Fill)", group="Style – S/R")
srColorSup    = input.color(sty.SR_COLOR_SUP,    "Support (Active Fill)",  group="Style – S/R")
srColorValid  = input.color(sty.SR_COLOR_VALID,  "Validated Zone",       group="Style – S/R")
srColorBroken = input.color(sty.SR_COLOR_BROKEN, "Broken Zone",          group="Style – S/R")

// ⁕ Estilos – Fibonacci (padrões vindos de StyleLib)
fibBaseColor  = input.color(sty.FIB_BASE_COLOR,  "≤1× Base color", group="Style – Fib")
fibExtUpCol   = input.color(sty.FIB_EXT_UP_COL,  ">1× Up color", group="Style – Fib")
fibExtDnCol   = input.color(sty.FIB_EXT_DN_COL,  ">1× Down color", group="Style – Fib")
fibWidth      = input.int(sty.FIB_WIDTH,         "Line width", minval=1, maxval=4, group="Style – Fib")
labelSizeOpt  = input.string(sty.LABEL_SIZE,     "Label size", options=["tiny", "small", "normal"], group="Style – Fib")
labelOffset   = input.int(sty.LABEL_OFFSET,      "Label offset (bars)", minval=0, group="Style – Fib")

// REFINAMENTO VISUAL: Inputs para controlar os novos elementos gráficos
showPivotMarkers = input.bool(true, "Show S/R Pivot Markers", group="Style – Refinements")
showFibAnchors = input.bool(true, "Show Fibonacci Anchors", group="Style – Refinements")

// ─────────────────────────── Estruturas de Dados (UDT) ─────────────────────
const int MAX_SR_ZONES = 30
const int MAX_FIB_LEVELS = 20
const int MAX_CONF_BOXES = 40

type SR_Zone

    int bar_index
    line line_upper
    line line_lower
    linefill fill_obj
    label lbl
    float level
    float probability
    float x1
    float x2
    bool isSupport
    int retests = 0
    string status = "Active"

type FibLevel
    line ln
    label lbl
    float level
    float ratio
    int bar_index

var SR_Zone[] sr_zones = array.new<SR_Zone>()
var FibLevel[] fib_levels = array.new<FibLevel>()
var box[] confBoxes = array.new_box()
var float[] trainX1 = array.new<float>()
var float[] trainX2 = array.new<float>()
var float[] trainY  = array.new<float>()

// Determine which weights will be used for the logistic model. If a comma
// separated string is provided via input, parse it. Otherwise, attempt to
// train using the collected pivot history.
float finalW0 = logW0
float finalW1 = logW1
float finalW2 = logW2
if useTrainedWeights
    if str.length(weightsStr) > 0
        string[] parts = str.split(weightsStr, ",")
        if array.size(parts) >= 3
            finalW0 := str.tonumber(array.get(parts, 0))
            finalW1 := str.tonumber(array.get(parts, 1))
            finalW2 := str.tonumber(array.get(parts, 2))
    else if array.size(trainY) > 0
        lt.TrainResult res = lt.gradientDescent(trainX1, trainX2, trainY, trainRate, trainEpochs)
        finalW0 := res.w0
        finalW1 := res.w1
        finalW2 := res.w2

// ─────────────────────────── Funções de Gerenciamento ────────────────
f_pushZone(SR_Zone zone) =>
    array.push(sr_zones, zone)
    if array.size(sr_zones) > MAX_SR_ZONES
        SR_Zone oldZone = array.shift(sr_zones)
        line.delete(oldZone.line_upper)
        line.delete(oldZone.line_lower)
        linefill.delete(oldZone.fill_obj)
        label.delete(oldZone.lbl)

f_clearZones() =>
    for z in sr_zones
        line.delete(z.line_upper)
        line.delete(z.line_lower)
        linefill.delete(z.fill_obj)
        label.delete(z.lbl)
    array.clear(sr_zones)

f_clearFibLevels() =>
    for f in fib_levels
        line.delete(f.ln)
        label.delete(f.lbl)
    array.clear(fib_levels)

f_pushBox(box b) =>
    array.push(confBoxes, b)
    if array.size(confBoxes) > MAX_CONF_BOXES
        box.delete(array.shift(confBoxes))

f_clearBoxes() =>
    for b in confBoxes
        box.delete(b)
    array.clear(confBoxes)

// --- Lógica de Mercado ---
ph = pv.pivotHigh(high, length)
pl = pv.pivotLow(low, length)
rsi = ta.rsi(close, length)
atr = ta.atr(length)

// Cria uma nova zona S/R com base em um pivô e adiciona ao array global
f_createZone(float level, bool isSupport, color fillColor, color borderColor) =>
    float x1 = rsi > rsiThreshold ? 1 : -1
    float x2 = math.abs(close - open) > atr ? 1 : -1
    float prob = lr.logistic(x1, x2, finalW0, finalW1, finalW2)
    float pivRsi   = rsi[length]
    float pivOpen  = open[length]
    float pivClose = close[length]
    float pivAtr   = atr[length]

    if prob > probThreshold
        float atr_offset_local = pivAtr * volatilityBandATR
        float upper = level + atr_offset_local
        float lower = level - atr_offset_local
        line l_u = line.new(bar_index - length, upper, bar_index, upper, color=borderColor, extend=extend.right, style=line.style_solid, width=1)
        line l_l = line.new(bar_index - length, lower, bar_index, lower, color=borderColor, extend=extend.right, style=line.style_solid, width=1)
        linefill lf = linefill.new(l_u, l_l, color=fillColor)
        label newLbl = label.new(bar_index, level, "", style=label.style_none)
        f_pushZone(SR_Zone.new(bar_index, l_u, l_l, lf, newLbl, level, prob, x1, x2, isSupport))

// Processa reteste e validação de uma zona
f_handleRetest(SR_Zone zone) =>
    zone.retests += 1
    zone.lbl.set_text(str.tostring(zone.retests) + 'x')
    zone.lbl.set_x(bar_index + 1)
    zone.lbl.set_y(zone.level)
    zone.lbl.set_style(label.style_label_left)
    zone.lbl.set_size(size.tiny)
    zone.lbl.set_color(color.new(color.gray, 20))
    zone.lbl.set_textcolor(srColorValid)

    if zone.retests >= retestCount and zone.status != "Validated"
        zone.status := "Validated"
        zone.line_upper.set_color(borderColorValid)
        zone.line_lower.set_color(borderColorValid)
        zone.line_upper.set_width(2)
        zone.line_lower.set_width(2)
        zone.fill_obj.set_color(srColorValid)
        zone.lbl.set_text("✔")
        zone.lbl.set_color(color.new(srColorValid, 25))
        zone.lbl.set_textcolor(color.white)
        zone.lbl.set_tooltip("Zona Validada com " + str.tostring(zone.retests) + " retestes.")
        array.push(trainX1, zone.x1)
        array.push(trainX2, zone.x2)
        array.push(trainY, 1.0)

// Marca uma zona como rompida
f_markBroken(SR_Zone zone) =>
    zone.status := "Broken"
    zone.line_upper.set_color(borderColorBroken)
    zone.line_lower.set_color(borderColorBroken)
    zone.line_upper.set_style(line.style_dashed)
    zone.line_lower.set_style(line.style_dashed)
    zone.fill_obj.set_color(srColorBroken)
    zone.line_upper.set_extend(extend.none)
    zone.line_lower.set_extend(extend.none)
    zone.line_upper.set_x2(bar_index)
    zone.line_lower.set_x2(bar_index)
    zone.lbl.set_text("B")
    zone.lbl.set_textcolor(srColorBroken)
    zone.lbl.set_color(color.new(color.gray, 80))
    zone.lbl.set_tooltip("Zona rompida.")
    if zone.retests < retestCount
        array.push(trainX1, zone.x1)
        array.push(trainX2, zone.x2)
        array.push(trainY, 0.0)    

// --- Estado Global da Origem do Pivô ---
// Flags para marcar se um pivô foi formado na barra atual
bool isPivotHighOrigin = not na(ph) and na(pv.pivotHigh(high[1], length))
bool isPivotLowOrigin  = not na(pl) and na(pv.pivotLow(low[1], length))

// --- Lógica de Suporte / Resistência ---
if srEnabled
    borderColorRes := color.new(srColorRes, 75)
    borderColorSup := color.new(srColorSup, 75)
    borderColorValid := color.new(srColorValid, 50)
    borderColorBroken := color.new(srColorBroken, 85)

    if not na(ph)
        f_createZone(ph, false, srColorRes, borderColorRes)

    if not na(pl)
        f_createZone(pl, true, srColorSup, borderColorSup)

    for zone in sr_zones
        if zone.status != "Broken"
            bool isRetest = zone.isSupport ? low < zone.level and close >= zone.level : high > zone.level and close <= zone.level
            bool isBroken = zone.isSupport ? close < zone.level : close > zone.level
            
            if isRetest
                f_handleRetest(zone)

            if isBroken
                f_markBroken(zone)
else
    // Garante que os marcadores não sejam plotados se o subsistema estiver desativado
    isPivotHighOrigin := false
    isPivotLowOrigin := false

// --- Plotagem dos Marcadores de Pivô ---
// Só plota na barra de formação do pivô
plotshape(bar_index >= length and srEnabled and showPivotMarkers and isPivotHighOrigin ? ph : na, 
          title="PH Marker", style=shape.triangledown, location=location.absolute, 
          color=color.new(borderColorRes, 70), size=size.tiny, offset=0)
plotshape(bar_index >= length and srEnabled and showPivotMarkers and isPivotLowOrigin ? pl : na, 
          title="PL Marker", style=shape.triangleup, location=location.absolute, 
          color=color.new(borderColorSup, 70), size=size.tiny, offset=0)

// --- Lógica de Fibonacci ---
var float lastHigh = na
var float lastLow = na
var label fibAnchorHighLabel = na
var label fibAnchorLowLabel = na

// Só atualiza âncora quando um novo pivô é formado
if bar_index >= length
    if isPivotHighOrigin
        lastHigh := ph
        if showFibAnchors and fibEnabled
            label.delete(fibAnchorHighLabel)
            fibAnchorHighLabel := label.new(bar_index, ph, "⦿", style=sty.ANCHOR_STYLE, textcolor=sty.ANCHOR_TEXT_COLOR, size=sty.ANCHOR_SIZE, tooltip="Âncora Superior Fibonacci")
    if isPivotLowOrigin
        lastLow := pl
        if showFibAnchors and fibEnabled
            label.delete(fibAnchorLowLabel)
            fibAnchorLowLabel := label.new(bar_index, pl, "⦿", style=sty.ANCHOR_STYLE, textcolor=sty.ANCHOR_TEXT_COLOR, size=sty.ANCHOR_SIZE, tooltip="Âncora Inferior Fibonacci")

if fibEnabled and not na(lastHigh) and not na(lastLow) and barstate.isconfirmed
    f_clearFibLevels()
    float diff = math.abs(lastHigh - lastLow)
    bool isUp = lastHigh > lastLow
    float[] ratios = array.from(0.236, 0.382, 0.5, 0.618, 0.786, 1.0, 1.272, 1.414, 1.618, 2.0)
    for idx = 0 to array.size(ratios) - 1
        float r = array.get(ratios, idx)
        float y = isUp ? lastHigh + diff * r : lastLow - diff * r
        bool isExt = r > 1.0
        color lnCol = isExt ? (isUp ? fibExtUpCol : fibExtDnCol) : fibBaseColor
        line ln = line.new(bar_index, y, bar_index + 1, y, color=lnCol, style=isExt ? line.style_solid : line.style_dotted, width=fibWidth, extend=extend.right)
        string lblTxt = str.tostring(r * 100, "#.##") + "% → " + str.tostring(y, format.mintick)
        label lb = label.new(bar_index + (idx % 2 == 0 ? labelOffset : -labelOffset), y, text=lblTxt, xloc=xloc.bar_index, style=idx % 2 == 0 ? label.style_label_left : label.style_label_right, color=color.new(lnCol, 80), textcolor=lnCol, size=labelSizeOpt)
        array.push(fib_levels, FibLevel.new(ln, lb, y, r, bar_index))
else if not fibEnabled
    f_clearFibLevels()
    label.delete(fibAnchorHighLabel)
    label.delete(fibAnchorLowLabel)

if array.size(sr_zones) > 0 and array.size(fib_levels) > 0
    for zone in sr_zones
        if zone.status != "Broken"
            for fib in fib_levels
                if math.abs(zone.level - fib.level) < atr * confThresholdATR
                    conf.ConfluenceInput confluenceInput = conf.ConfluenceInput.new(fib.level, zone.level, zone.probability, atr, fib.bar_index, zone.retests, retestCount, zone.bar_index, 1.0, 50, w1, w2, w3, w4)
                    conf.CalculatedWeights result = conf.calculateConfluence(confluenceInput)
                    float score = result.confluence_weight
                    if score > 0
                        color boxBgColor = color.from_gradient(score, 0.5, 1.5, color.yellow, color.purple)
                        string confTooltip = "Confluência: " + str.tostring(score, "#.##") + "\nS/R Nível: " + str.tostring(zone.level) + "\nFib Nível: " + str.tostring(fib.level) + " (" + str.tostring(fib.ratio * 100, "#.##") + "%)" + "\nS/R Retestes: " + str.tostring(zone.retests)
                        box confBox = box.new(bar_index, math.max(zone.level, fib.level), bar_index + confluenceBoxWidth, math.min(zone.level, fib.level), bgcolor=color.new(boxBgColor, 70), border_color=color.new(boxBgColor, 40), text="✨ " + str.tostring(score, "#.##"), text_halign=text.align_center)
                        f_pushBox(confBox)
else
    f_clearBoxes()
