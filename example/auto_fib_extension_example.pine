//@version=6
indicator("Auto Fib Extension Refatorado", overlay=true)

// === INPUTS ===
// Pivot settings
depthInput        = input.int(10, "Pivot Depth", minval=2, tooltip="Bar depth for pivot detection")
reverseInput      = input.bool(false, "Reverse Direction", inline="Rev")

// Line extension
extendLeftInput   = input.bool(false, "Extend Left", inline="Ext")
extendRightInput  = input.bool(true,  "Extend Right", inline="Ext")
extendMode   = extend.none
if      extendLeftInput and extendRightInput
    extendMode := extend.both
else if extendLeftInput
    extendMode := extend.left
else if extendRightInput
    extendMode := extend.right

// Display options
showPricesInput   = input.bool(true,  "Show Prices")
showLevelsInput   = input.bool(true,  "Show Levels")
labelPosInput     = input.string("Left", "Labels Position", options=["Left","Right"])
valueFormatInput  = input.string("Values", "Levels Format", options=["Values","Percent"])
alphaBgInput      = input.int(85,   "Background Transparency", minval=0, maxval=100)

// Thresholds
upperThreshInput  = input.float(0.236, "Upper Ratio Threshold")
lowerThreshInput  = input.float(1.0,   "Lower Ratio Threshold")

// Fibonacci ratios and colors
var float[] fibRatios = array.new<float>()
var color[] fibColors = array.new<color>()
var int prevAlphaBg = na

// Allocate the arrays only once and rebuild when transparency changes
if barstate.isfirst or prevAlphaBg != alphaBgInput
    array.clear(fibRatios)
    array.clear(fibColors)
    array.push(fibRatios, 0.0)
    array.push(fibRatios, 0.236)
    array.push(fibRatios, 0.382)
    array.push(fibRatios, 0.5)
    array.push(fibRatios, 0.618)
    array.push(fibRatios, 0.786)
    array.push(fibRatios, 1.0)
    array.push(fibRatios, 1.618)
    array.push(fibColors, color.new(color.blue,     alphaBgInput))
    array.push(fibColors, color.new(color.teal,     alphaBgInput))
    array.push(fibColors, color.new(color.green,    alphaBgInput))
    array.push(fibColors, color.new(color.yellow,   alphaBgInput))
    array.push(fibColors, color.new(color.orange,   alphaBgInput))
    array.push(fibColors, color.new(color.fuchsia,  alphaBgInput))
    array.push(fibColors, color.new(color.gray,     alphaBgInput))
    array.push(fibColors, color.new(color.red,      alphaBgInput))
    prevAlphaBg := alphaBgInput

// === UTILS ===
// Draw a line or update existing
f_drawLine(_price, _col, _lastLine) =>
    var line newLine = na
    if na(_lastLine)
        newLine := line.new(time, _price, time, _price, color=_col, width=1, extend=extendMode, xloc=xloc.bar_time)
    else
        line.set_xy1(_lastLine, line.get_x1(_lastLine), _price)
        line.set_xy2(_lastLine, line.get_x2(_lastLine), _price)
        newLine := _lastLine
    newLine

// Draw a label or update existing
f_drawLabel(_price, _text, _col, _refLine) =>
    if na(_price)
        na
    x = labelPosInput == "Left" ? line.get_x1(_refLine) : line.get_x2(_refLine)
    style = labelPosInput == "Left" ? label.style_label_right : label.style_label_left
    align = labelPosInput == "Left" ? text.align_right : text.align_left
    textFmt = labelPosInput == "Left" ? _text + "\n" : "       " + _text + "\n"
    var label lbl = label.new(x, _price, textFmt, textcolor=_col, style=style, textalign=align, color=#00000000, xloc=xloc.bar_time)
    label.set_xy(lbl, x, _price)
    label.set_text(lbl, textFmt)
    lbl

// === PIVOT & FIB CALCULATION ===
f_calculate() =>
    // Detect pivot: simplistic high/low comparisonâ€”replace with custom logic if needed
    isHighPivot = na(ta.pivothigh(high, depthInput, depthInput))
    isLowPivot  = na(ta.pivotlow(low, depthInput, depthInput))

    // Track last pivot prices
    var float lastHigh = na
    var float lastLow  = na
    if isHighPivot
        lastHigh := high[depthInput]
    if isLowPivot
        lastLow  := low[depthInput]

    // Determine start/end for fib
    pivotHigh = lastHigh
    pivotLow  = lastLow
    isHighLast = na(pivotHigh) == false and pivotHigh > pivotLow

    startP = isHighLast ? pivotHigh : pivotLow
    endP   = isHighLast ? pivotLow  : pivotHigh
    diff   = math.abs(startP - endP)

    // Validate threshold
    valid = isHighLast ? (pivotLow < endP - diff * lowerThreshInput or pivotLow > endP - diff * upperThreshInput) : (pivotHigh > endP + diff * lowerThreshInput or pivotHigh < endP + diff * upperThreshInput)

    if valid
        [endP, diff]
    else
        [na, na]

[endPrice, span] = f_calculate()

// Show a warning instead of halting execution when there is not enough data
var label warnLbl = na
if barstate.islast and na(endPrice)
    // Display a persistent label on the latest bar
    warnLbl := na(warnLbl) ? label.new(bar_index, close, "Mais hist\u00f3rico\nrequerido",
                                       color=color.new(color.red, 0),
                                       style=label.style_label_down) : warnLbl
    label.set_xy(warnLbl, bar_index, close)
    label.set_text(warnLbl, "Mais hist\u00f3rico\nrequerido")
    alert("Auto Fib Extension requer hist\u00f3rico adicional", alert.freq_once_per_bar_close)
else
    if not na(warnLbl)
        label.delete(warnLbl)
        warnLbl := na

// === DRAW FIB LEVELS ===
var line lastLine = na
var label lastLbl = na
if not na(endPrice) and showLevelsInput
    for i = 0 to array.size(fibRatios) - 1
        ratio = array.get(fibRatios, i)
        lvl   = endPrice + span * ratio
        col   = array.get(fibColors, i)

        // draw lines
        lastLine := f_drawLine(lvl, col, lastLine)

        // draw labels
        if showPricesInput
            txt = valueFormatInput == "Percent" ? str.tostring(ratio * 100, "#.#") + "%" : str.tostring(lvl, "#.##")
            lastLbl := f_drawLabel(lvl, txt, col, lastLine)

    // Reset references for next bar
    lastLine := na
    lastLbl  := na
else
    // Clean up drawn objects when levels are hidden or calculation failed
    line.delete(lastLine)
    label.delete(lastLbl)
