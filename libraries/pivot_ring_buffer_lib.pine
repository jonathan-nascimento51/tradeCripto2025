//@version=6
library("PivotRingBuffer", true)

import "./style_lib.pine" as st

// -----------------------------------------------------------------------------
// PivotCandidate type represents a potential pivot before confirmation
// -----------------------------------------------------------------------------
export type PivotCandidate
    float price
    int   barIdx
    bool  isHigh

export type RingBuffer
    PivotCandidate[] buffer
    int              capacity

export newRingBuffer(int cap) =>
    RingBuffer.new(array.new<PivotCandidate>(), math.max(1, cap))

// -----------------------------------------------------------------------------
// setCapacity
// Allows adjusting the maximum number of stored candidates
// -----------------------------------------------------------------------------
export setCapacity(RingBuffer self, int cap) =>
    self.capacity := math.max(1, cap)
    while array.size(self.buffer) > self.capacity
        array.shift(self.buffer)

// -----------------------------------------------------------------------------
// clearBuffer
// Removes all stored candidates
// -----------------------------------------------------------------------------
export clearBuffer(RingBuffer self) =>
    array.clear(self.buffer)

// -----------------------------------------------------------------------------
// processCandidate
// Detects raw pivots using ta.pivothigh/low with right=0 and stores them.
// After rightBars have passed, validates each candidate and plots markers.
// Returns the prices of confirmed pivot high and low (na when none).
// -----------------------------------------------------------------------------
export processCandidate(RingBuffer self, float highSrc, float lowSrc, int leftBars, int rightBars) =>
    float resHigh = na
    float resLow  = na
    st.Styles styles = st.getStyles()

    // Detect new pivot candidates immediately when the left side condition holds
    float hCand = ta.pivothigh(highSrc, leftBars, 0)
    if not na(hCand)
        array.push(self.buffer, PivotCandidate.new(hCand, bar_index, true))

    float lCand = ta.pivotlow(lowSrc, leftBars, 0)
    if not na(lCand)
        array.push(self.buffer, PivotCandidate.new(lCand, bar_index, false))

    // Enforce ring buffer capacity
    while array.size(self.buffer) > self.capacity
        array.shift(self.buffer)

    int i = 0
    while i < array.size(self.buffer)
        PivotCandidate cand = array.get(self.buffer, i)
        int age = bar_index - cand.barIdx
        if age >= rightBars
            if age == rightBars
                bool valid = cand.isHigh ? cand.price >= ta.highest(highSrc, rightBars + 1)
                                           : cand.price <= ta.lowest(lowSrc, rightBars + 1)
                if valid
                    if cand.isHigh
                        resHigh := cand.price
                        plotshape(cand.price, title="Pivot High", style=shape.triangledown,
                                  
                                  location=location.absolute, color=styles.fib_ext_dn_col,
                                  offset=-rightBars, size=size.tiny)
                    else
                        resLow := cand.price
                        plotshape(cand.price, title="Pivot Low", style=shape.triangleup,
                                  
                                  location=location.absolute, color=styles.fib_ext_up_col,
                                  offset=-rightBars, size=size.tiny)
            array.remove(self.buffer, i)
        else
            i += 1

    [resHigh, resLow]
