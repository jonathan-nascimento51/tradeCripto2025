//@version=6
// @description Biblioteca para detectar pivôs e devolvê‑los já validados
library("PivotRingBuffer")

// -----------------------------------------------------------------------------
// Tipos
// -----------------------------------------------------------------------------
export type PivotCandidate
    float price      // Preço do pivô bruto
    int   barIdx     // Índice da barra onde ocorreu
    bool  isHigh     // true = pivô de máxima, false = mínima

export type RingBuffer
    PivotCandidate[] buffer // Fila circular dos candidatos
    int              capacity // Número máximo de candidatos guardados
// -----------------------------------------------------------------------------
// Construtor
// -----------------------------------------------------------------------------

export newRingBuffer(int cap) =>
    RingBuffer.new(array.new<PivotCandidate>(), math.max(1, cap))

// -----------------------------------------------------------------------------
// Ajusta a capacidade máxima
// -----------------------------------------------------------------------------
export setCapacity(RingBuffer self, int cap) =>
    self.capacity := math.max(1, cap)
    while array.size(self.buffer) > self.capacity
        array.shift(self.buffer)

// -----------------------------------------------------------------------------
// Limpa o buffer
// -----------------------------------------------------------------------------
export clearBuffer(RingBuffer self) =>
    array.clear(self.buffer)

// -----------------------------------------------------------------------------
// processCandidate
//  • Detecta pivôs brutos usando ta.pivothigh/low com right = 0;
//  • Armazena‑os no buffer;
//  • Após rightBars barras, valida o pivô contra o extremo mais alto/baixo do período;
//  • Devolve [highValidated, lowValidated] com na quando inexistente.
// -----------------------------------------------------------------------------
export processCandidate(RingBuffer self, series float highSrc, series float lowSrc, int leftBars, int rightBars) =>
    float resHigh = na
    float resLow  = na

    // 1) novos candidatos
    float hCand = ta.pivothigh(highSrc, leftBars, 0)
    if not na(hCand)
        array.push(self.buffer, PivotCandidate.new(hCand, bar_index, true))

    float lCand = ta.pivotlow(lowSrc, leftBars, 0)
    if not na(lCand)
        array.push(self.buffer, PivotCandidate.new(lCand, bar_index, false))

    // 2) aplica capacidade de forma FIFO
    while array.size(self.buffer) > self.capacity
        array.shift(self.buffer)

    // 3) valida e remove expirados
    int i = 0
    while i < array.size(self.buffer)
        PivotCandidate cand = array.get(self.buffer, i)
        int age = bar_index - cand.barIdx

        if age >= rightBars
            if age == rightBars
                bool valid = cand.isHigh ? cand.price >= ta.highest(highSrc, rightBars + 1) : cand.price <= ta.lowest(lowSrc, rightBars + 1)
                if valid
                    if cand.isHigh
                        resHigh := cand.price
                    else
                        resLow  := cand.price
            // remove o candidato, validado ou não
            array.remove(self.buffer, i)
        else
            i += 1

    [resHigh, resLow]
